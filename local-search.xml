<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>raft&amp;bitcask 键值存储数据库</title>
    <link href="/2024/06/26/raft/"/>
    <url>/2024/06/26/raft/</url>
    
    <content type="html"><![CDATA[<p>关于用 go 实现一个由 raft 分布式一致性协议和 bitcask 存储模型搭建的分布式键值存储数据库。</p><h2 id="raft"><a href="#raft" class="headerlink" title="raft"></a>raft</h2><p>实现上，raft 的实现来自于 MIT 6.824 课程实践 lab 的调整。主要集中于内部调用方式上用 grpc 协议取代了该 lab 原有的 channel 模拟，以及对于命令实现的调整。<br>命令应被传入当前的 leader 处，在这里由一个 subscriber 的机制来完成。该 subscriber 与应用处于同一层级，会接收到 raft 集群内部的命令但不会进行响应，只负责来记录 leader 的变更备应用使用。<br>只要命令通过 RPC 调用恰当的传入当前 leader，该 leader 确认后就会返回命令接受，立即开始日志同步，而调用该命令者则认为该命令已经被执行。但实际上，命令的真正执行时间，是 leader 确认半数节点接受命令后 apply 该日志时，则该日志所代表的命令会返回给真正的执行方开始执行。<br>当然，这边的执行方可以是任何实现了定义的 Command 接口的结构。</p><h2 id="bitcask"><a href="#bitcask" class="headerlink" title="bitcask"></a>bitcask</h2><p>bitcask 是真正的执行方。<br>bitcask 模型是一个经典的键值对存储模型。其使用日志形式管理键值对存储。<br>其核心在于追加写模式和 merge hint 过程。追加写而不修改之前的内容保证了键值对结构的紧密排列和高效率。而 merge hint 过程，则保证了查找时的效率。merge 即从前往后遍历之前的文件，只保留不被删除和覆盖的键值对一步步生成新的文件。而 hint 即 merge 过程可以顺便生成的索引。其值存储的是真正的值所在的文件和偏移量。<br>内部实现上我们还是围绕接口进行，如文件读写形式（传统 IO，mmap，iouring 等）和内存索引（BtreeMap，HashMap）等。保证了可拓展性和模块化。</p><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><p>接着，我们需要划分宏观上的实现形式：即一个机器（或者说一个 provider ）拥有一个 raft client 和 bitcask。多个 provider 组成一个 cluster，内部使用 raft 完成通信。多个 cluster 组成一个 server ，对外由客户端使用一致性哈希完成负载均衡。<br>源码如下：<br><a href="https://github.com/iku50/raft-kv">https://github.com/iku50/raft-kv</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>raft</tag>
      
      <tag>bitcask</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gorm-note</title>
    <link href="/2024/06/26/gorm-note/"/>
    <url>/2024/06/26/gorm-note/</url>
    
    <content type="html"><![CDATA[<h2 id="关于-gorm-框架进行-mysql-CRUD-的使用心得"><a href="#关于-gorm-框架进行-mysql-CRUD-的使用心得" class="headerlink" title="关于 gorm 框架进行 mysql CRUD 的使用心得"></a>关于 gorm 框架进行 mysql CRUD 的使用心得</h2><p>关于 ORM 框架，需要注意其利弊兼有的特点，其虽可以帮助我们简化一些简单 sql 操作，做一些辅助检查，但性能低，复杂查询表达不如直接使用 sql 的缺点是存在的。<br>对于简单查询，使用 ORM 框架是不错的，但综合性能和编写效率，复杂查询还是手写 sql 比较好。<br>综合一下还是觉得 java 中 MyBatis plus 负责简单查询，MyBatis 手写 sql 复杂查询的模式更好一些。<br>至于多表操作，其实有以下几个方案：</p><ol><li>冗余字段或其他存储（redis 等）：其实这个最快，如果可以通过冗余一两个字段完成操作最好。</li><li>本地多次单表查询：想提前返回错误或者要进行检查。</li><li>join：性能其实相比本地多次单表查因为网络IO更快。但要注意较容易慢 sql。<br>实际业务进行选择，尽量避免三张表及以上的多表操作。<br>关于 join 还有很多优化策略，但这篇重点不是这个。</li></ol><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>为了更好的使用 gorm，省去简单查询的重复编写是不可少的一步，可以使用 gorm-gen 负责生成代码，但有时会对生成的代码并不满意（比如方法实现上想做出调整），可以参照我下面结合泛型给出的例子：<br>单表查询的泛型，具体步骤如下：<br>定义类型限制的 interface，类似于下面这样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Model <span class="hljs-keyword">interface</span> &#123;<br>TableName() <span class="hljs-type">string</span><br>GetID() <span class="hljs-type">int64</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接着针对该 Model，定义相关的单表 Dao 接口和结构，方法实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Interface of Dao[Model]</span><br><span class="hljs-keyword">type</span> IDao[M Model <span class="hljs-keyword">interface</span> &#123;  <br>    Create(ctx context.Context, m M) <span class="hljs-type">error</span><br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">// Struct of Dao[Model]</span><br><span class="hljs-keyword">type</span> MDao[T Model <span class="hljs-keyword">struct</span> &#123;  <br>    *gorm.DB  <br>&#125;<br><br><span class="hljs-comment">// Create Method of MDao</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MDao[T])</span></span> Create(ctx context.Context, t T) <span class="hljs-type">error</span> &#123;  <br>    r := m.WithContext(ctx).Table(t.TableName()).Clauses(  <br>       clause.OnConflict&#123;  <br>          DoNothing: <span class="hljs-literal">true</span>,  <br>       &#125;).  <br>       Create(&amp;t)  <br>    <span class="hljs-keyword">return</span> r.Error  <br>&#125;<br><br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>用 MDao 对 IDao 进行实现相关方法完成。<br>而对于具体使用而言，我们可以定义一个多表接口 Dao</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Dao <span class="hljs-keyword">struct</span> &#123;  <br>    ProductDao      gormer.IDao[*model.Product]  <br>    OrderDao        gormer.IDao[*model.BusinessOrder]<br>    <span class="hljs-comment">// 这里可以对 DB 做一些直接操作的接口，比如复杂查询或者事务</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面只是个简单的例子，实际业务中还要看情况选择使用。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="建表规范"><a href="#建表规范" class="headerlink" title="建表规范"></a>建表规范</h3><p>建表规范不同，其中要注意的几点是：</p><ul><li>主键字段</li><li>created_at，updated_at，deleted_at 等字段</li><li>valid 字段</li><li>CHARSET 是 utf8 还是 utf8mb4</li><li>注释</li></ul><h3 id="注意零值"><a href="#注意零值" class="headerlink" title="注意零值"></a>注意零值</h3><p>注意数据库中不要规定任何值为 0 的数据为有实际意义的值，其作为数值使用的数值型类型，比如类似于 enum 使用的字段，因为如果在 gorm 的插入或修改中定义某值为 0，gorm 会认为该值不需要插入或修改，在某些情况下这样可能酿成大错。<br>如果想插入或更新零值，可以使用诸如 <code>&quot;0&quot;</code> 的做法。</p><h3 id="对象返回"><a href="#对象返回" class="headerlink" title="对象返回"></a>对象返回</h3><p>首先，永远不要返回双 nil，因为我们往往只检查 err。<br>对于对象的一对一关系，父子关系等等：</p><ul><li>一对一：返回与主对象有父关系的所有数据，他们为对象提供了基本上下文</li><li>一对多：知道子关系数量有限时才返回子关系</li></ul><h3 id="列表或搜寻"><a href="#列表或搜寻" class="headerlink" title="列表或搜寻"></a>列表或搜寻</h3><p>我们需要实现一个 Filter 结构对结果进行过滤，分页等等</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>应该确定的是，对逻辑而言，如果可以保证每一个函数调用都是一个独立的事务，世界会变得更美好。当然世界肯定不是完美的。<br>同时，应该设计事务平铺的机制以支持在 service 层操作被视为单独的事务。</p><h3 id="方法命名"><a href="#方法命名" class="headerlink" title="方法命名"></a>方法命名</h3><p>我个人使用的规范是：对于 ByA ，A 为 ID 时不加该后缀，对于增删改操作，后缀 <code>Batch</code> 代表批量进行</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><p>虽然查找上一般都能直接查找全部数据，但 <code>Select</code> 方法是减少查询时间下必须的。</p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">subQuery := db.Select(<span class="hljs-string">&quot;AVG(age)&quot;</span>).Where(<span class="hljs-string">&quot;name LIKE ?&quot;</span>, <span class="hljs-string">&quot;name%&quot;</span>).Table(<span class="hljs-string">&quot;users&quot;</span>)  <br>db.Select(<span class="hljs-string">&quot;AVG(age) as avgage&quot;</span>).Group(<span class="hljs-string">&quot;name&quot;</span>).Having(<span class="hljs-string">&quot;AVG(age) &gt; (?)&quot;</span>, subQuery).Find(&amp;results)<br><span class="hljs-comment">// 或者在 Table 中直接使用，相当于 sql 的 from</span><br>db.Table(<span class="hljs-string">&quot;(?) as u&quot;</span>, db.Model(&amp;User&#123;&#125;).Select(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>)).Where(<span class="hljs-string">&quot;age = ?&quot;</span>, <span class="hljs-number">18</span>).Find(&amp;User&#123;&#125;)<br></code></pre></td></tr></table></figure><h3 id="查找或创建"><a href="#查找或创建" class="headerlink" title="查找或创建"></a>查找或创建</h3><p>使用 <code>Attrs().FirstOrCreate()</code> 或者使用 <code>Assign().FirstOrCreate()</code> 两者的区别是前者在找到后就不会使用 <code>Attrs</code> 中的属性，而后者即使找到也会使用 <code>Assign</code> 中的属性进行更新。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Where(User&#123;Name: <span class="hljs-string">&quot;non_existing&quot;</span>&#125;).Attrs(User&#123;Age: <span class="hljs-number">20</span>&#125;).FirstOrInit(&amp;user)<br></code></pre></td></tr></table></figure><h3 id="索引提示"><a href="#索引提示" class="headerlink" title="索引提示"></a>索引提示</h3><p>对查询语句提示其应该使用哪个索引</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Clauses(hints.UseIndex(<span class="hljs-string">&quot;idx_user_name&quot;</span>)).Find(&amp;User&#123;&#125;)<br></code></pre></td></tr></table></figure><h3 id="迭代处理"><a href="#迭代处理" class="headerlink" title="迭代处理"></a>迭代处理</h3><p>使用迭代处理，可以比较轻易的实现树形结构查询等复杂查询情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">rows, err := db.Model(&amp;User&#123;&#125;).Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;jinzhu&quot;</span>).Rows()  <br><span class="hljs-keyword">defer</span> rows.Close()  <br>  <br><span class="hljs-keyword">for</span> rows.Next() &#123;  <br>  <span class="hljs-keyword">var</span> user User  <br>  <span class="hljs-comment">// ScanRows 扫描每一行进结构体  </span><br>  db.ScanRows(rows, &amp;user)  <br>  <span class="hljs-comment">// 对每一个 User 进行操作  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面是一个树形结构查询例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">trees := []model.CategoryTree&#123;&#125;<br>rows, err := db.Table(TableNameCategory).Where(<span class="hljs-string">&quot;root = ?&quot;</span>,<span class="hljs-number">1</span>)Rows()<br><span class="hljs-keyword">defer</span> rows.Close()<br><br>treeSearch<br><span class="hljs-keyword">for</span> rows.Next() &#123;<br><span class="hljs-keyword">var</span> c model.Category<br>db.ScanRows(rows, &amp;c)<br>trees = <span class="hljs-built_in">append</span>(trees, model.CategoryTree&#123;<br>Value: c<br>&#125;)<br>rows,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="批量查询"><a href="#批量查询" class="headerlink" title="批量查询"></a>批量查询</h3><p>使用 <code>FindInBatches</code> 进行批量查询，批量查询应该使用事务进行处理。</p><h3 id="单列查询"><a href="#单列查询" class="headerlink" title="单列查询"></a>单列查询</h3><p>使用 <code>Pluck</code> 方法进行单列查询进切片中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ages []<span class="hljs-type">int64</span>  <br>db.Model(&amp;User&#123;&#125;).Pluck(<span class="hljs-string">&quot;age&quot;</span>, &amp;ages)<br></code></pre></td></tr></table></figure><h3 id="自定义查询函数"><a href="#自定义查询函数" class="headerlink" title="自定义查询函数"></a>自定义查询函数</h3><p>如分页函数等对 pageSize，page 等等进行检查，使用 <code>Scopes</code> 完成类似于方法的定义更有利于规范。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Paginate</span><span class="hljs-params">(pageSize, page <span class="hljs-type">int</span>)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(db *gorm.DB)</span></span> *gorm.DB &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(db *gorm.DB)</span></span> *gorm.DB &#123;  <br>       <span class="hljs-keyword">if</span> page &lt;= <span class="hljs-number">0</span> &#123;  <br>          page = <span class="hljs-number">1</span>  <br>       &#125;  <br>       <span class="hljs-keyword">switch</span> &#123;  <br>       <span class="hljs-keyword">case</span> pageSize &gt; <span class="hljs-number">100</span>:  <br>          pageSize = <span class="hljs-number">100</span>  <br>       <span class="hljs-keyword">case</span> pageSize &lt;= <span class="hljs-number">0</span>:  <br>          pageSize = <span class="hljs-number">10</span>  <br>       &#125;  <br>  <br>       offset := (page - <span class="hljs-number">1</span>) * pageSize  <br>       fmt.Println(offset, pageSize)  <br>       <span class="hljs-keyword">return</span> db.Limit(pageSize).Offset(offset)  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分页相关"><a href="#分页相关" class="headerlink" title="分页相关"></a>分页相关</h3><p>首先，如果需要使用非唯一性索引分页排序，需要搭配唯一性索引，否则无法确保一致性。同时也需要确定非唯一性索引是否是联合索引。如果是，在中间以最左匹配原则加入联合索引的其他键可以进一步优化效率。<br>大分页下我们需要进行的查询如果使用非主键索引，需要进行多次回表效率极低，这里可以用延迟关联+覆盖索引实现高效分页查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> contacts          <span class="hljs-comment">-- 想要展示给用户的完整数据。</span><br>    <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> (                <span class="hljs-comment">-- &quot;延迟关联&quot;。</span><br>        <span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> contacts <span class="hljs-comment">-- 使用快速索引进行分页。</span><br>            <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id<br>            limit <span class="hljs-number">15</span> <span class="hljs-keyword">offset</span> <span class="hljs-number">150000</span><br>    ) <span class="hljs-keyword">as</span> tmp <span class="hljs-keyword">using</span>(id)<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id                     <span class="hljs-comment">-- 对单个结果页进行排序。</span><br></code></pre></td></tr></table></figure><p>综合以上，分页在 gorm 的实现应该是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">r := ds.Table(model.TableNameProduct).Select(<span class="hljs-string">&quot;product.id&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>).  <br>    Joins(<span class="hljs-string">&quot;INNER JOIN (?) as tmp ON tmp.id = product.id&quot;</span>,  <br>       ds.Table(model.TableNameProduct).Select(<span class="hljs-string">&quot;id&quot;</span>).  <br>          Where(<span class="hljs-string">&quot;valid = ? and gem_valid = ?&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>).  <br>          Count(&amp;count).Limit(pageSize).Offset(page).  <br>          Order(<span class="hljs-string">&quot;id desc&quot;</span>), model.TableNameProduct).  <br>    Order(<span class="hljs-string">&quot;id desc&quot;</span>).Find(&amp;products)<br></code></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入可以分为几种类型，最简单的单次插入，以及批量插入，树形结构插入，插入或修改（upsert）等等。</p><h3 id="单次插入"><a href="#单次插入" class="headerlink" title="单次插入"></a>单次插入</h3><p>如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">res := ds.WithContext(ctx).Table(model.TableNameApp).Create(&amp;m)<br></code></pre></td></tr></table></figure><p>基本上只需要使用 <code>Create</code> 即可，这里也可以使用 <code>Save</code> ，其会将所有字段（包括零值字段）插入，但一般来说在良好的数据库定义和上文对零值的注意下并不需要，且对于某些比如 <code>created_ad</code> 等需要在数据库中使用 default 进行维护等字段，<code>Save</code> 就有些不实用了。</p><h3 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h3><p>使用 <code>CreatedInBatched</code> 方法。</p><h3 id="创建或更新"><a href="#创建或更新" class="headerlink" title="创建或更新"></a>创建或更新</h3><p>我们经常需要预计到创建或更新的情况，即唯一性约束被触犯时，我们两种应对方法（返回或者更新原值），这两种都可以用 <code>gorm</code> 的 <code>Clauses</code> 方法解决，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">ds.WithContext(ctx).Table(model.TableNameGoods).Clauses(  <br>   clause.OnConflict&#123;  <br>      Columns:   []clause.Column&#123;&#123;Name: <span class="hljs-string">&quot;name&quot;</span>&#125;&#125;,  <br>      DoUpdates: clause.AssignmentColumns([]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;desc&quot;</span>,<span class="hljs-string">&quot;info&quot;</span>&#125;),  <br>   &#125;).Create(&amp;good)<br></code></pre></td></tr></table></figure><p>这里的 <code>OnConflict</code> 中有几种像 <code>DoUpdates</code> 这样的解决方案，分别是 <code>DoUpdates</code>，<code>DoNothing</code> 和 <code>UpdateAll</code> ，后两种是布尔值，只需说明是否需要进行此过程即可，<code>Columns</code> 中是被冒犯到的唯一性约束。<br>实际上，<code>Clauses</code> 还有其他妙用。</p><h3 id="树形结构插入"><a href="#树形结构插入" class="headerlink" title="树形结构插入"></a>树形结构插入</h3><p>树形结构插入需要注意</p><ul><li>子节点往往需要父节点的 ID 作为 <code>parent_id</code>，这就意味着父节点的插入一定要在子节点之前。</li><li>对于一棵较大的树而言，我们需要用批量插入的形式来尽量减少 sql 的次数。这就意味着深度优先插入劣于广度优先（广度优先可以一次性返回）<br>也就时说，我们可以将树形结构插入分成这样的几个步骤：</li></ul><ol><li>定义插入过程，这里可以用匿名函数。</li><li>定义广度优先算法，更新当前层级和下一需要进行更新的层级。</li><li>使用事务，将上面的插入过程和广度优先更新层级的过程统合。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义插入过程</span><br><span class="hljs-keyword">var</span> create <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(goods *[]model.Good)</span></span> <span class="hljs-type">error</span>  <br>create = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(goods *[]model.Auth)</span></span> <span class="hljs-type">error</span> &#123;  <br>    <span class="hljs-comment">// 插入过程</span><br>&#125;  <br><br><span class="hljs-comment">// 定义广度优先过程</span><br>nextLevel := <span class="hljs-built_in">make</span>([]model.GoodTree, <span class="hljs-number">0</span>)  <br>creates := <span class="hljs-built_in">make</span>([]model.Good, <span class="hljs-number">0</span>)  <br>  <br><span class="hljs-keyword">var</span> getLevel <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(goodtree *[]model.GoodTree)</span></span>  <br>getLevel = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(goods *[]model.GoodTree)</span></span> &#123;  <br>    nextLevel = <span class="hljs-built_in">make</span>([]model.GoodTree, <span class="hljs-number">0</span>)  <br>    creates = <span class="hljs-built_in">make</span>([]model.Good, <span class="hljs-number">0</span>)  <br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> *goodtree &#123;  <br>       creates = <span class="hljs-built_in">append</span>(creates, v.Value)  <br>       <span class="hljs-keyword">for</span> _, nv := <span class="hljs-keyword">range</span> v.Children &#123;  <br>      <span class="hljs-comment">// 要注意的是这里因为插入完成所以 v.Value.ID 在这时候就存在了</span><br>          nv.Value.ParentID = v.Value.ID  <br>          nextLevel = <span class="hljs-built_in">append</span>(nextLevel, *nv)  <br>       &#125;    <br>    &#125;  <br>&#125;  <br><br><span class="hljs-comment">// 使用事务进行实际更新</span><br>tx := ds.DB.WithContext(ctx).Begin()  <br><span class="hljs-keyword">if</span> tx.Error != <span class="hljs-literal">nil</span> &#123;  <br>    <span class="hljs-keyword">return</span> errors.WithStack(tx.Error)  <br>&#125;  <br><br>getLevel(data)  <br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(creates) &gt; <span class="hljs-number">0</span> &#123;  <br>    err = create(&amp;creates)  <br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;  <br>       tx.Rollback()  <br>       <span class="hljs-keyword">return</span> errors.WithStack(err)  <br>    &#125;  <br>    getLevel(&amp;nextLevel)  <br>&#125;  <br><span class="hljs-keyword">return</span> tx.Commit().Error<br></code></pre></td></tr></table></figure></li></ol><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>一般都不真删除而是 update 逻辑删除相关的字段。</p><h4 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h4><p>逻辑删除基本是实际业务中必备的。<br>逻辑删除时针对可能影响唯一性约束时，可以有三种解决方案：</p><ul><li>将删除标记设置默认值(例如 0 )，将唯一字段与删除标记添加唯一键约束。当某一记录需要删除时，将删除标记置为 NULL。<br>  由于 NULL 不会和其他字段有组合唯一键的效果，所以当记录被删除时(删除标记被置为 NULL 时)，解除了唯一键的约束。此外该方法能很好地解决批量删除的问题(只要置为 NULL 就完事了)，消耗的空间也并不多( 1 位 + 联合索引)。 但 NULL 本身就可能出现问题。 </li><li>将删除标记更新为主键，这样同样保证了唯一约束字段和删除标记组合索引的唯一性。</li><li>引入 <code>deleted_at</code> 字段，和唯一字段组成联合唯一索引，进行逻辑删除时同步更新。<br>最后一种解决方式基本是可以保证不会出现什么问题的<br>引入 gorm 自带的软删除机制通过<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123; <br>ID <span class="hljs-type">int</span> Deleted <br>gorm.DeletedAt <br>Name <span class="hljs-type">string</span> <br>&#125;<br></code></pre></td></tr></table></figure>查找被软删除的记录可以通过 <code>Unscoped</code> 解决<br>在上文中提到的最后一种和唯一字段组成联合唯一索引的方法，可以通过如下代码进行支持<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;gorm.io/plugin/soft_delete&quot;</span> <br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123; <br>ID <span class="hljs-type">uint</span> <br>Name <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;uniqueIndex:udx_name&quot;`</span> <br>DeletedAt soft_delete.DeletedAt <span class="hljs-string">`gorm:&quot;uniqueIndex:udx_name&quot;`</span> <br>&#125;<br></code></pre></td></tr></table></figure><code>gorm.io/plugin/soft_delete</code> 还提供了上文的删除标记方法：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;gorm.io/plugin/soft_delete&quot;</span> <br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123; <br>ID <span class="hljs-type">uint</span> <br>Name <span class="hljs-type">string</span> <br>IsDel soft_delete.DeletedAt <span class="hljs-string">`gorm:&quot;softDelete:flag&quot;`</span> <br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>gorm</tag>
      
      <tag>go</tag>
      
      <tag>orm</tag>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>wayland 在 2023 的实际体验</title>
    <link href="/2023/12/06/wayland%20in%202023/"/>
    <url>/2023/12/06/wayland%20in%202023/</url>
    
    <content type="html"><![CDATA[<h2 id="关于-wayland-的一些问题和相关配置"><a href="#关于-wayland-的一些问题和相关配置" class="headerlink" title="关于 wayland 的一些问题和相关配置"></a>关于 wayland 的一些问题和相关配置</h2><p>这篇文章主要关于我在使用 wayland 时遇到的一些问题和相关配置，主要是一些软件的配置，以及一些问题的解决方案。</p><p>首先, 我们要了解 wayland 是什么而我为什么要使用 wayland。</p><h3 id="什么是-wayland"><a href="#什么是-wayland" class="headerlink" title="什么是 wayland"></a>什么是 wayland</h3><p>根据 archwiki 的解释:</p><blockquote><p>Wayland is a display server protocol. It is aimed to become the successor of the X Window System.<br>Wayland 是一个显示服务器协议，它的目标是成为 X Window System 的继承者。</p></blockquote><p>显示服务器又是什么呢? 显示服务器是位于图形界面和内核之间的一个软件，它负责接收来自应用程序的图形数据，然后将其转换为内核能够理解的数据，并将其发送给内核，内核再将其发送给显卡，显卡进行具体的渲染工作。</p><p>显示服务器协议本质上是一种通信协议，它规定了应用程序和显示服务器之间的通信方式，以及应用程序和显示服务器之间的通信内容。</p><p>旧有的 X Window System 是由 X.org 基金会管理的显示服务器开源实现,它通过 x11 协议与应用程序进行交互, X Window System 负责管控所有窗口的所有控件, 几十年发展下累计了各种补丁和问题, 其对于现代 linux 来说, 有些过于臃肿庞大。</p><p>于是 wayland 应时而生, 它的显示服务器(又名 Compositor)规定让客户机(应用程序)自身负责窗口边框和装饰等的绘制和处理输入, 窗口管理器简化为显示管理服务, 仅负责窗口算绘屏幕上的程序。</p><p>这里以 wikipedia 上的例子, 说明 Wayland 相比于 X 的高效设计的具体体现:</p><blockquote><p>以一次 “鼠标点击按钮引发按钮更新动作为例子”:<br>在 X 中:</p><ol><li>内核捕获鼠标点击事件并发送给X server。</li><li>X server会计算该把这一事件发送给哪个窗口（事实上，窗口位置是由Compositor控制的，X server并不能够正确的计算Compositor做过特效变化之后的按钮的正确位置）。</li><li>应用程序对此事件进行处理（将引发按钮更新动作）。但是，在此之前它得向X server发送绘制请求。</li><li>X server接收到这条绘制请求，然后把它发给视频驱动来渲染。X还计算了更新区域，并且这条“垃圾信息”发送给了Compositor。</li><li>这时，Compositor知道它必须要重新合成屏幕上的一块区域。当然，这还是要向X server发送绘制请求的。</li><li>开始绘制。但是X server还会去做一些不必要的本职工作（窗口重叠计算、窗口剪裁计算等）。</li></ol><p>在 Wayland 中</p><ol><li>内核捕获鼠标点击事件并发送给Wayland Compositor。</li><li>由于是直接发给Wayland Compositor的，所以Wayland Compositor会正确地计算出按钮的位置。同时它会把这一事件发送给按钮所在的应用程序来处理。</li><li>应用程序直接渲染，无需向Wayland Compositor请求。只需在绘制完成之后向Wayland Compositor发送一条信息表明这块区域被更新了。</li><li>Wayland Compositor收到这条信息后，立即重新合成整个桌面。</li></ol></blockquote><p>wayland 拥有更好的性能(简化架构, 简化图形堆栈, 设计更集中), 更高的安全性(应用程序之间相互独立), 更好的支持现代图形特性</p><h3 id="有关-wayland-的配置"><a href="#有关-wayland-的配置" class="headerlink" title="有关 wayland 的配置"></a>有关 wayland 的配置</h3><p>尽管 wayland 有上述的各种优势, 但受限于兼容问题, 其实际的体验还受到多多限制, 尽管在日常使用上已经基本没什么问题, 但在某些地方还待完善和改进</p><p>我目前使用的是 KDE 桌面环境, KDE 在对于 wayland 的支持上还是十分热心的, 目前社区中许多 Wayland 的适配中都能看到 KDE 开发人员的贡献, 而为何不使用诸如 hyprland 等备受好评的平铺式 Compositor, 只能说其在某些领域(比如 electron)等的表现还不太能令人满意</p><h4 id="关于-nvidia-显卡"><a href="#关于-nvidia-显卡" class="headerlink" title="关于 nvidia 显卡"></a>关于 nvidia 显卡</h4><p>相比几年前, nvidia 终于提高了他们对 wayland 的驱动支持力度, 目前在驱动问题上, 只需要一些简单的配置就能得到非常不错的 wayland 体验</p><p><em>以下针对使用 grub 启动的 archlinux 环境</em>:</p><p>安装好显卡对应的驱动后, 编辑 <code>/etc/environment</code>, 添加以下环境变量:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">GBM_BACKEND=nvidia-drm <span class="hljs-comment"># 使用 nvidia 的 gbm 后端</span><br>__GLX_VENDOR_LIBRARY_NAME=nvidia <span class="hljs-comment"># openGL 使用 nvidia 的库</span><br>ENABLE_VKBASALT=1 <span class="hljs-comment"># 开启 vulkan 的后处理</span><br>LIBVA_DRIVER_NAME=nvidia <span class="hljs-comment"># 使用 nvidia 的 vaapi 驱动</span><br>GDK_BACKEND=wayland <span class="hljs-comment"># GTK 支持</span><br>QT_QPA_PLATFORMTHEME=<span class="hljs-string">&quot;wayland;xcb&quot;</span> <span class="hljs-comment"># QT 支持</span><br>KWIN_DRM_USE_EGL_STREAMS=1 <span class="hljs-comment"># 使用 EGLStream 作为 kwin 的渲染后端</span><br></code></pre></td></tr></table></figure><p>然后, 编辑 <code>/etc/default/grub</code>, 找到 <code>GRUB_CMDLINE_LINUX_DEFAULT</code>,为其添加参数 <code>nvidia-drm.modeset=1</code></p><p>然后重新生成一下 grub 的 config</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo grub-mkconfig -o /boot/grub/grub.cfg<br></code></pre></td></tr></table></figure><p>编辑 <code>/etc/mkinitcpio.conf</code>, 在  <code>MODULES</code> 中添加 <code>nvidia nvidia_modeset nvidia_uvm nvidia_drm</code></p><p>然后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo mkinitcpio -P<br></code></pre></td></tr></table></figure><p>重启即可</p><p>另外, 有双显卡的最好使用混合显卡</p><h4 id="关于-kde"><a href="#关于-kde" class="headerlink" title="关于 kde"></a>关于 kde</h4><p>关于 kde, 只需要安装 <code>plasma-wayland-session plasma-wayland-protocols qt5-wayland qt6-wayland xorg-xwayland</code> 等包即可</p><h4 id="从-Xwayland-到-Wayland"><a href="#从-Xwayland-到-Wayland" class="headerlink" title="从 Xwayland 到 Wayland"></a>从 Xwayland 到 Wayland</h4><p>Xwayland 是对于某些还不能支持 wayland 协议的应用提供允许其在wayland 上运行 X11 应用程序的支持, 但对于那些已经支持 wayland 的应用, 为什么我们不使用它呢 ?</p><p>首先是 Firefox</p><p>设置环境变量 <code>MOZ_ENABLE_WAYLAND</code> 为 1 即可</p><p>然后是 electron 应用(包括 chrome)(还有 linux QQ, wechat-uos 等等)</p><p>在 <code>/usr/share/application</code> 中对应的启动参数添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">--enable-features=UseOzonePlatform<br>--ozone-platform=wayland<br></code></pre></td></tr></table></figure><h5 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h5><p>可以使用 <code>xeyes</code> 小眼睛看该应用程序是否使用 wayland 协议, 如果是, 眼睛就不会动</p><h4 id="关于输入法"><a href="#关于输入法" class="headerlink" title="关于输入法"></a>关于输入法</h4><p>参考 <a href="https://www.csslayer.info/wordpress/fcitx-dev/chrome-state-of-input-method-on-wayland/">Chrome&#x2F;Chromium 今日 wayland 支持现状</a> 下方评论(文章中反应的部分问题已在今天得到解决), KDE 下的 QT, GTK, Chrome 等应用均可使用 fcitx5 输入法</p><p>在 KDE 使用输入法及其简单, 在设置的虚拟键盘中选择 fcitx5 即可</p><p>对于 Chrome 系应用在这里要做说明, 在 xwayland 下基本能正常使用输入法, 但在 wayland 下, 需要添加启动参数 <code>--enable-wayland-ime</code> 才可以</p><h4 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h4><p>wayland 下不能使用 <code>flameshot</code>, 其截屏配置起来十分麻烦, 但我在 KDE 下找到了相应的应用程序, <code>spectacle</code>, 设置好相应快捷键后还是十分顺滑的</p><h3 id="体验效果"><a href="#体验效果" class="headerlink" title="体验效果"></a>体验效果</h3><p>在实际体验上, 相比 X, wayland 的动画效果十分流畅, 高刷新屏幕下可以得到非常好的体验, 而在笔记本上的电池耗电更是显著下降,就个人而言,在 X 下的耗电不如 windows, 两个小时以内就能将我的 r7000p 榨干, 而在 wayland 下, 实际续航在同等工作强度下可以支持三个小时以上</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从 08 年到 23 年, wayland 用 15 年时间稳步接近其目标, 为现代 linux 系统的发展奠定了坚实基础, 我相信在不久的将来, wayland 将会成为 linux 图形化的主流, 为 linux 的现代化, 高效化, 安全化提供更好的支持</p><p>另外, wayland 的高效使其能够为低端廉价设备提供图形化支持, 为 linux 在嵌入式领域的进一步发展提供了可能</p>]]></content>
    
    
    
    <tags>
      
      <tag>wayland</tag>
      
      <tag>linux</tag>
      
      <tag>x11</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
