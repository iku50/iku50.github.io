<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>wayland 在 2023 的实际体验</title>
    <link href="/2023/12/06/wayland%20in%202023/"/>
    <url>/2023/12/06/wayland%20in%202023/</url>
    
    <content type="html"><![CDATA[<h2 id="关于-wayland-的一些问题和相关配置"><a href="#关于-wayland-的一些问题和相关配置" class="headerlink" title="关于 wayland 的一些问题和相关配置"></a>关于 wayland 的一些问题和相关配置</h2><p>这篇文章主要关于我在使用 wayland 时遇到的一些问题和相关配置，主要是一些软件的配置，以及一些问题的解决方案。</p><p>首先, 我们要了解 wayland 是什么而我为什么要使用 wayland。</p><h3 id="什么是-wayland"><a href="#什么是-wayland" class="headerlink" title="什么是 wayland"></a>什么是 wayland</h3><p>根据 archwiki 的解释:</p><blockquote><p>Wayland is a display server protocol. It is aimed to become the successor of the X Window System.<br>Wayland 是一个显示服务器协议，它的目标是成为 X Window System 的继承者。</p></blockquote><p>显示服务器又是什么呢? 显示服务器是位于图形界面和内核之间的一个软件，它负责接收来自应用程序的图形数据，然后将其转换为内核能够理解的数据，并将其发送给内核，内核再将其发送给显卡，显卡进行具体的渲染工作。</p><p>显示服务器协议本质上是一种通信协议，它规定了应用程序和显示服务器之间的通信方式，以及应用程序和显示服务器之间的通信内容。</p><p>旧有的 X Window System 是由 X.org 基金会管理的显示服务器开源实现,它通过 x11 协议与应用程序进行交互, X Window System 负责管控所有窗口的所有控件, 几十年发展下累计了各种补丁和问题, 其对于现代 linux 来说, 有些过于臃肿庞大。</p><p>于是 wayland 应时而生, 它的显示服务器(又名 Compositor)规定让客户机(应用程序)自身负责窗口边框和装饰等的绘制和处理输入, 窗口管理器简化为显示管理服务, 仅负责窗口算绘屏幕上的程序。</p><p>这里以 wikipedia 上的例子, 说明 Wayland 相比于 X 的高效设计的具体体现:</p><blockquote><p>以一次 “鼠标点击按钮引发按钮更新动作为例子”:<br>在 X 中:</p><ol><li>内核捕获鼠标点击事件并发送给X server。</li><li>X server会计算该把这一事件发送给哪个窗口（事实上，窗口位置是由Compositor控制的，X server并不能够正确的计算Compositor做过特效变化之后的按钮的正确位置）。</li><li>应用程序对此事件进行处理（将引发按钮更新动作）。但是，在此之前它得向X server发送绘制请求。</li><li>X server接收到这条绘制请求，然后把它发给视频驱动来渲染。X还计算了更新区域，并且这条“垃圾信息”发送给了Compositor。</li><li>这时，Compositor知道它必须要重新合成屏幕上的一块区域。当然，这还是要向X server发送绘制请求的。</li><li>开始绘制。但是X server还会去做一些不必要的本职工作（窗口重叠计算、窗口剪裁计算等）。</li></ol><p>在 Wayland 中</p><ol><li>内核捕获鼠标点击事件并发送给Wayland Compositor。</li><li>由于是直接发给Wayland Compositor的，所以Wayland Compositor会正确地计算出按钮的位置。同时它会把这一事件发送给按钮所在的应用程序来处理。</li><li>应用程序直接渲染，无需向Wayland Compositor请求。只需在绘制完成之后向Wayland Compositor发送一条信息表明这块区域被更新了。</li><li>Wayland Compositor收到这条信息后，立即重新合成整个桌面。</li></ol></blockquote><p>wayland 拥有更好的性能(简化架构, 简化图形堆栈, 设计更集中), 更高的安全性(应用程序之间相互独立), 更好的支持现代图形特性</p><h3 id="有关-wayland-的配置"><a href="#有关-wayland-的配置" class="headerlink" title="有关 wayland 的配置"></a>有关 wayland 的配置</h3><p>尽管 wayland 有上述的各种优势, 但受限于兼容问题, 其实际的体验还受到多多限制, 尽管在日常使用上已经基本没什么问题, 但在某些地方还待完善和改进</p><p>我目前使用的是 KDE 桌面环境, KDE 在对于 wayland 的支持上还是十分热心的, 目前社区中许多 Wayland 的适配中都能看到 KDE 开发人员的贡献, 而为何不使用诸如 hyprland 等备受好评的平铺式 Compositor, 只能说其在某些领域(比如 electron)等的表现还不太能令人满意</p><h4 id="关于-nvidia-显卡"><a href="#关于-nvidia-显卡" class="headerlink" title="关于 nvidia 显卡"></a>关于 nvidia 显卡</h4><p>相比几年前, nvidia 终于提高了他们对 wayland 的驱动支持力度, 目前在驱动问题上, 只需要一些简单的配置就能得到非常不错的 wayland 体验</p><p><em>以下针对使用 grub 启动的 archlinux 环境</em>:</p><p>安装好显卡对应的驱动后, 编辑 <code>/etc/environment</code>, 添加以下环境变量:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">GBM_BACKEND=nvidia-drm <span class="hljs-comment"># 使用 nvidia 的 gbm 后端</span><br>__GLX_VENDOR_LIBRARY_NAME=nvidia <span class="hljs-comment"># openGL 使用 nvidia 的库</span><br>ENABLE_VKBASALT=1 <span class="hljs-comment"># 开启 vulkan 的后处理</span><br>LIBVA_DRIVER_NAME=nvidia <span class="hljs-comment"># 使用 nvidia 的 vaapi 驱动</span><br>GDK_BACKEND=wayland <span class="hljs-comment"># GTK 支持</span><br>QT_QPA_PLATFORMTHEME=<span class="hljs-string">&quot;wayland;xcb&quot;</span> <span class="hljs-comment"># QT 支持</span><br>KWIN_DRM_USE_EGL_STREAMS=1 <span class="hljs-comment"># 使用 EGLStream 作为 kwin 的渲染后端</span><br></code></pre></td></tr></table></figure><p>然后, 编辑 <code>/etc/default/grub</code>, 找到 <code>GRUB_CMDLINE_LINUX_DEFAULT</code>,为其添加参数 <code>nvidia-drm.modeset=1</code></p><p>然后重新生成一下 grub 的 config</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo grub-mkconfig -o /boot/grub/grub.cfg<br></code></pre></td></tr></table></figure><p>编辑 <code>/etc/mkinitcpio.conf</code>, 在  <code>MODULES</code> 中添加 <code>nvidia nvidia_modeset nvidia_uvm nvidia_drm</code></p><p>然后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo mkinitcpio -P<br></code></pre></td></tr></table></figure><p>重启即可</p><p>另外, 有双显卡的最好使用混合显卡</p><h4 id="关于-kde"><a href="#关于-kde" class="headerlink" title="关于 kde"></a>关于 kde</h4><p>关于 kde, 只需要安装 <code>plasma-wayland-session plasma-wayland-protocols qt5-wayland qt6-wayland xorg-xwayland</code> 等包即可</p><h4 id="从-Xwayland-到-Wayland"><a href="#从-Xwayland-到-Wayland" class="headerlink" title="从 Xwayland 到 Wayland"></a>从 Xwayland 到 Wayland</h4><p>Xwayland 是对于某些还不能支持 wayland 协议的应用提供允许其在wayland 上运行 X11 应用程序的支持, 但对于那些已经支持 wayland 的应用, 为什么我们不使用它呢 ?</p><p>首先是 Firefox</p><p>设置环境变量 <code>MOZ_ENABLE_WAYLAND</code> 为 1 即可</p><p>然后是 electron 应用(包括 chrome)(还有 linux QQ, wechat-uos 等等)</p><p>在 <code>/usr/share/application</code> 中对应的启动参数添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">--enable-features=UseOzonePlatform<br>--ozone-platform=wayland<br></code></pre></td></tr></table></figure><h5 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h5><p>可以使用 <code>xeyes</code> 小眼睛看该应用程序是否使用 wayland 协议, 如果是, 眼睛就不会动</p><h4 id="关于输入法"><a href="#关于输入法" class="headerlink" title="关于输入法"></a>关于输入法</h4><p>参考 <a href="https://www.csslayer.info/wordpress/fcitx-dev/chrome-state-of-input-method-on-wayland/">Chrome&#x2F;Chromium 今日 wayland 支持现状</a> 下方评论(文章中反应的部分问题已在今天得到解决), KDE 下的 QT, GTK, Chrome 等应用均可使用 fcitx5 输入法</p><p>在 KDE 使用输入法及其简单, 在设置的虚拟键盘中选择 fcitx5 即可</p><p>对于 Chrome 系应用在这里要做说明, 在 xwayland 下基本能正常使用输入法, 但在 wayland 下, 需要添加启动参数 <code>--enable-wayland-ime</code> 才可以</p><h4 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h4><p>wayland 下不能使用 <code>flameshot</code>, 其截屏配置起来十分麻烦, 但我在 KDE 下找到了相应的应用程序, <code>spectacle</code>, 设置好相应快捷键后还是十分顺滑的</p><h3 id="体验效果"><a href="#体验效果" class="headerlink" title="体验效果"></a>体验效果</h3><p>在实际体验上, 相比 X, wayland 的动画效果十分流畅, 高刷新屏幕下可以得到非常好的体验, 而在笔记本上的电池耗电更是显著下降,就个人而言,在 X 下的耗电不如 windows, 两个小时以内就能将我的 r7000p 榨干, 而在 wayland 下, 实际续航在同等工作强度下可以支持三个小时以上</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从 08 年到 23 年, wayland 用 15 年时间稳步接近其目标, 为现代 linux 系统的发展奠定了坚实基础, 我相信在不久的将来, wayland 将会成为 linux 图形化的主流, 为 linux 的现代化, 高效化, 安全化提供更好的支持</p><p>另外, wayland 的高效使其能够为低端廉价设备提供图形化支持, 为 linux 在嵌入式领域的进一步发展提供了可能</p>]]></content>
    
    
    
    <tags>
      
      <tag>wayland</tag>
      
      <tag>linux</tag>
      
      <tag>x11</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
